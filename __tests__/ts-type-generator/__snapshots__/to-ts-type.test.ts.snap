// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`toTsType should correctly add export statements when exporting all should add \`declare\` 1`] = `
"export declare type Array1 = Array<number>;


export declare type FooList = Array<string>;


export declare type Main = {
  unnamed: Array1;
  foo: FooList;
};
"
`;

exports[`toTsType should correctly add export statements when exporting all should not add \`declare\` 1`] = `
"export type Array1 = Array<number>;


export type FooList = Array<string>;


export type Main = {
  unnamed: Array1;
  foo: FooList;
};
"
`;

exports[`toTsType should correctly add export statements when exporting only main should add \`declare\` 1`] = `
"declare type FooList = Array<string>;


export declare type Main = {
  foo: FooList;
};
"
`;

exports[`toTsType should correctly add export statements when exporting only main should not add \`declare\` 1`] = `
"type FooList = Array<string>;


export type Main = {
  foo: FooList;
};
"
`;

exports[`toTsType should correctly add export statements when exporting only named should add \`declare\` 1`] = `
"declare type Array1 = Array<number>;


export declare type FooList = Array<string>;


export declare type Main = {
  unnamed: Array1;
  foo: FooList;
};
"
`;

exports[`toTsType should correctly add export statements when exporting only named should not add \`declare\` 1`] = `
"type Array1 = Array<number>;


export type FooList = Array<string>;


export type Main = {
  unnamed: Array1;
  foo: FooList;
};
"
`;

exports[`toTsType should correctly add external type import statements and export it directly if it's a root type 1`] = `
"import type { IsStringFn } from "./is-string-fn.d.ts";
export { IsStringFn };
"
`;

exports[`toTsType should correctly add external type import statements with regular Custom validator 1`] = `
"import type { CustomFoo } from "./custom-validator.d.ts";

export type Record1 = {
  foo: CustomFoo;
};
"
`;

exports[`toTsType should correctly add external type import statements with regular Enum 1`] = `
"import type { MyEnum } from "./enum.d.ts";

export type Record1 = {
  foo: MyEnum;
};
"
`;

exports[`toTsType should correctly add external type import statements with regular Enum Member 1`] = `
"import type { MyEnum } from "./enum.d.ts";

export type Record1 = {
  foo: MyEnum.C;
};
"
`;

exports[`toTsType should correctly add external type import statements with regular Function as a type 1`] = `
"import type { MyFunction } from "./my-function.d.ts";

export type Record1 = {
  foo: MyFunction;
};
"
`;

exports[`toTsType should correctly add external type import statements with regular Function as a value 1`] = `
"import type { myFunction } from "./my-function.d.ts";

export type Record1 = {
  foo: typeof myFunction;
};
"
`;

exports[`toTsType should correctly generate a complex type with 'compact' mode 1`] = `
"export type TestRecord = {
  /**
   * User unique identifier
   */
  uuid: string;
  number: number;
  bool: boolean;
  stringSet: Set<string>;
  stringArray: Array<string>;
  /**
   * Array of two possible record types
   */
  unionArray: Array<{
    foo: string;
  } | {
    bar: string;
  }>;
  tuple: [string, number];
  /**
   * A tuple with a named type
   */
  namedTuple: [Array<string>, Enum];
  literalString: "literal";
  literalNumber: 1;
  literalBoolean: true;
  enum: Enum;
  bMember: Enum.B;
  recordIntersection: {
    a: string;
  } & {
    b: number;
  };
  dict: Record<string | number, string>;
  oneof: {
    foo: string;
  } | {
    bar: string;
  };
  symbol: symbol;
  undef: undefined;
  customValidator: unknown;
  stringMatching: string;
  namedStringMatching: '\\'foo\\'.\${string}';
  /**
   * A record identical to the parent record, but with all fields optional
   */
  optionalSelfCopy?: {
    id?: string;
    number?: number;
    bool?: boolean;
    stringSet?: Set<string>;
    stringArray?: Array<string>;
    unionArray?: Array<{
      foo: string;
    } | {
      bar: string;
    }>;
    tuple?: [string, number];
    literalString?: "literal";
    literalNumber?: 1;
    literalBoolean?: true;
    enum?: Enum;
    bMember?: Enum.B;
    recordIntersection?: {
      a: string;
    } & {
      b: number;
    };
    dict?: Record<string | number, string>;
    oneof?: {
      foo: string;
    } | {
      bar: string;
    };
  };
};
"
`;

exports[`toTsType should correctly generate a complex type with 'fully-expanded' mode 1`] = `
"type Set1 = Set<string>;


type Array1 = Array<string>;


type Record1 = {
  foo: string;
};


type Record2 = {
  bar: string;
};

/**
 * Array of two possible record types
 */
type Array2 = Array<Record1 | Record2>;


type Tuple1 = [string, number];


type Array3 = Array<string>;

/**
 * A tuple with a named type
 */
type ATuple = [Array3, Enum];


type Record3 = {
  a: string;
};


type Record4 = {
  b: number;
};


type Intersection1 = Record3 & Record4;


type Dict1 = Record<string | number, string>


type FooContainer = {
  foo: string;
};


type BarContainer = {
  bar: string;
};


type Union1 = FooContainer | BarContainer;


type StringMatching1 = string;


type FooMatcher = '\\'foo\\'.\${string}';


type Set2 = Set<string>;


type Array4 = Array<string>;


type FooContainer1 = {
  foo: string;
};


type Record5 = {
  bar: string;
};


type Array5 = Array<FooContainer1 | Record5>;


type Tuple2 = [string, number];


type Record6 = {
  a: string;
};


type Record7 = {
  b: number;
};


type SomeIntersection = Record6 & Record7;


type Dict2 = Record<string | number, string>


type Record8 = {
  foo: string;
};


type Record9 = {
  bar: string;
};


type Union2 = Record8 | Record9;

/**
 * A record identical to the parent record, but with all fields optional
 */
type OptionalTestRecord = {
  id?: string;
  number?: number;
  bool?: boolean;
  stringSet?: Set2;
  stringArray?: Array4;
  unionArray?: Array5;
  tuple?: Tuple2;
  literalString?: "literal";
  literalNumber?: 1;
  literalBoolean?: true;
  enum?: Enum;
  bMember?: Enum.B;
  recordIntersection?: SomeIntersection;
  dict?: Dict2;
  oneof?: Union2;
};


export type TestRecord = {
  /**
   * User unique identifier
   */
  uuid: string;
  number: number;
  bool: boolean;
  stringSet: Set1;
  stringArray: Array1;
  /**
   * Array of two possible record types
   */
  unionArray: Array2;
  tuple: Tuple1;
  /**
   * A tuple with a named type
   */
  namedTuple: ATuple;
  literalString: "literal";
  literalNumber: 1;
  literalBoolean: true;
  enum: Enum;
  bMember: Enum.B;
  recordIntersection: Intersection1;
  dict: Dict1;
  oneof: Union1;
  symbol: symbol;
  undef: undefined;
  customValidator: unknown;
  stringMatching: StringMatching1;
  namedStringMatching: FooMatcher;
  /**
   * A record identical to the parent record, but with all fields optional
   */
  optionalSelfCopy?: OptionalTestRecord;
};
"
`;

exports[`toTsType should correctly generate a complex type with 'named-expanded' mode 1`] = `
"/**
 * A tuple with a named type
 */
type ATuple = [Array<string>, Enum];


type FooContainer = {
  foo: string;
};


type BarContainer = {
  bar: string;
};


type FooMatcher = '\\'foo\\'.\${string}';


type FooContainer1 = {
  foo: string;
};


type SomeIntersection = {
  a: string;
} & {
  b: number;
};

/**
 * A record identical to the parent record, but with all fields optional
 */
type OptionalTestRecord = {
  id?: string;
  number?: number;
  bool?: boolean;
  stringSet?: Set<string>;
  stringArray?: Array<string>;
  unionArray?: Array<FooContainer1 | {
    bar: string;
  }>;
  tuple?: [string, number];
  literalString?: "literal";
  literalNumber?: 1;
  literalBoolean?: true;
  enum?: Enum;
  bMember?: Enum.B;
  recordIntersection?: SomeIntersection;
  dict?: Record<string | number, string>;
  oneof?: {
    foo: string;
  } | {
    bar: string;
  };
};


export type TestRecord = {
  /**
   * User unique identifier
   */
  uuid: string;
  number: number;
  bool: boolean;
  stringSet: Set<string>;
  stringArray: Array<string>;
  /**
   * Array of two possible record types
   */
  unionArray: Array<{
    foo: string;
  } | {
    bar: string;
  }>;
  tuple: [string, number];
  /**
   * A tuple with a named type
   */
  namedTuple: ATuple;
  literalString: "literal";
  literalNumber: 1;
  literalBoolean: true;
  enum: Enum;
  bMember: Enum.B;
  recordIntersection: {
    a: string;
  } & {
    b: number;
  };
  dict: Record<string | number, string>;
  oneof: FooContainer | BarContainer;
  symbol: symbol;
  undef: undefined;
  customValidator: unknown;
  stringMatching: string;
  namedStringMatching: FooMatcher;
  /**
   * A record identical to the parent record, but with all fields optional
   */
  optionalSelfCopy?: OptionalTestRecord;
};
"
`;

exports[`toTsType should correctly generate a type referencing a class in compact mode with global FooBar 1`] = `
"export type Record1 = {
  foobar: InstanceType<typeof FooBar>;
};
"
`;

exports[`toTsType should correctly generate a type referencing a class in compact mode with imported FooBar 1`] = `
"import type { FooBar } from "./foo-bar";

export type Record1 = {
  foobar: InstanceType<typeof FooBar>;
};
"
`;

exports[`toTsType should correctly generate a type referencing a class in fully-expanded mode with global FooBar 1`] = `
"type ClassInstance1 = InstanceType<typeof FooBar>


export type Record1 = {
  foobar: ClassInstance1;
};
"
`;

exports[`toTsType should correctly generate a type referencing a class in fully-expanded mode with global FooBar 2`] = `
"type AliasFooBar = InstanceType<typeof FooBar>


export type Record1 = {
  foobar: AliasFooBar;
};
"
`;

exports[`toTsType should correctly generate a type referencing a class in fully-expanded mode with imported FooBar 1`] = `
"import type { FooBar } from "./foo-bar";

type ClassInstance1 = InstanceType<typeof FooBar>


export type Record1 = {
  foobar: ClassInstance1;
};
"
`;

exports[`toTsType should correctly generate a type referencing a class in fully-expanded mode with imported FooBar 2`] = `
"import type { FooBar } from "./foo-bar";

type AliasFooBar = InstanceType<typeof FooBar>


export type Record1 = {
  foobar: AliasFooBar;
};
"
`;
