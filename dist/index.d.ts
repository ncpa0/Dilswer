declare const _default: {
    createChecker: <DT extends import("./types").AllDataTypes>(dataType: DT) => (data: unknown) => data is import("./type-utils").ReWrap<import("./type-utils").ParseDataType<DT>>;
    createValidator: <DT extends import("./types").AllDataTypes>(dataType: DT) => (data: unknown) => data is import("./type-utils").ReWrap<import("./type-utils").ParseDataType<DT>>;
    createTypeGuardedFunction: <DT_1 extends import("./types").AllDataTypes, R, ER = void>(dataType: DT_1, onValidationSuccess: (data: import("./type-utils").ReWrap<import("./type-utils").ParseDataType<DT_1>>) => R, onValidationError?: ((error: import("./checker-machine/validation-error/validation-error").ValidationError, passedData: unknown) => ER) | undefined) => (data: unknown) => R | ER;
    createValidatedFunction: <DT_1 extends import("./types").AllDataTypes, R, ER = void>(dataType: DT_1, onValidationSuccess: (data: import("./type-utils").ReWrap<import("./type-utils").ParseDataType<DT_1>>) => R, onValidationError?: ((error: import("./checker-machine/validation-error/validation-error").ValidationError, passedData: unknown) => ER) | undefined) => (data: unknown) => R | ER;
    ensureDataType: <DT_2 extends import("./types").AllDataTypes>(dataType: DT_2, data: unknown) => void;
    And: <R1 extends import("./types").RecordTypeSchema, R2 extends import("./types").RecordTypeSchema>(recordDataTypeA: import("./types").RecordOf<R1>, recordDataTypeB: import("./types").RecordOf<R2>) => import("./utilities/types").SumRecord<R1, R2>;
    Exclude: <U extends import("./types").OneOf<any[]>, E extends "string" | "number" | "boolean" | "symbol" | "undefined" | "function" | "unknown" | "null">(union: U, ...excludeTypes: E[]) => import("./utilities/types").ExcludeOneOf<U, E>;
    Omit: <R_1 extends import("./types").RecordTypeSchema, K extends keyof R_1>(recordDataType: import("./types").RecordOf<R_1>, ...omitKeys: readonly K[]) => import("./utilities/types").OmitRecord<R_1, K>;
    Partial: <R_2 extends import("./types").RecordTypeSchema>(recordDataType: import("./types").RecordOf<R_2>) => import("./utilities/types").PartialRecord<R_2>;
    Pick: <R_3 extends import("./types").RecordTypeSchema, K_1 extends keyof R_3>(recordDataType: import("./types").RecordOf<R_3>, ...pickKeys: readonly K_1[]) => import("./utilities/types").PickRecord<R_3, K_1>;
    Required: <R_4 extends import("./types").RecordTypeSchema>(recordDataType: import("./types").RecordOf<R_4>) => import("./utilities/types").RequiredRecord<R_4>;
    DataType: {
        RecordOf<TS extends import("./types").RecordTypeSchema>(args: TS): import("./types").RecordOf<TS>;
        ArrayOf<DT_3 extends import("./types").AllDataTypes[]>(...args: DT_3): import("./types").ArrayOf<DT_3>;
        SetOf<DT_4 extends import("./types").AllDataTypes[]>(...args: DT_4): import("./types").SetOf<DT_4>;
        OneOf<DT_5 extends import("./types").AllDataTypes[]>(...args: DT_5): import("./types").OneOf<DT_5>;
        Literal<V extends string | number | boolean>(value: V): import("./types").Literal<V>;
        EnumMember<M extends string | number>(enumMember: M): import("./types").EnumMember<M>;
        Enum<T extends string, TEnumValue extends string | number>(enumInstance: { [key in T]: TEnumValue; }): import("./types").Enum<TEnumValue>;
        Unknown: "unknown";
        String: "string";
        Number: "number";
        Boolean: "boolean";
        Symbol: "symbol";
        Function: "function";
        Null: "null";
        Undefined: "undefined";
    };
};
export default _default;
export { createChecker, createValidator, } from "./checker-machine/create-checker";
export { createTypeGuardedFunction, createValidatedFunction, } from "./checker-machine/create-validated-function";
export { ensureDataType } from "./checker-machine/ensure-data-type";
export { DataType } from "./type-def-helpers";
export { GetDataType } from "./type-utils";
export { AllDataTypes, ArrayOf, BasicDataType, ComplexDataType, Enum, EnumMember, FieldDescriptor, Literal, OneOf, RecordOf, RecordTypeSchema as TypeSchema, SetOf, } from "./types";
export * from "./utilities";
