declare const _default: {
    createChecker: <DT extends import("./data-types/types").AllDataTypes>(dataType: DT) => (data: unknown) => data is import("./data-types/type-utils").ReWrap<import("./data-types/type-utils").ParseDataType<DT>>;
    createValidator: <DT extends import("./data-types/types").AllDataTypes>(dataType: DT) => (data: unknown) => data is import("./data-types/type-utils").ReWrap<import("./data-types/type-utils").ParseDataType<DT>>;
    createTypeGuardedFunction: <DT_1 extends import("./data-types/types").AllDataTypes, R, ER = void>(dataType: DT_1, onValidationSuccess: (data: import("./data-types/type-utils").ReWrap<import("./data-types/type-utils").ParseDataType<DT_1>>) => R, onValidationError?: ((error: import("./validation-algorithms/validation-error/validation-error").ValidationError, passedData: unknown) => ER) | undefined) => (data: unknown) => R | ER;
    createValidatedFunction: <DT_1 extends import("./data-types/types").AllDataTypes, R, ER = void>(dataType: DT_1, onValidationSuccess: (data: import("./data-types/type-utils").ReWrap<import("./data-types/type-utils").ParseDataType<DT_1>>) => R, onValidationError?: ((error: import("./validation-algorithms/validation-error/validation-error").ValidationError, passedData: unknown) => ER) | undefined) => (data: unknown) => R | ER;
    ensureDataType: <DT_2 extends import("./data-types/types").AllDataTypes>(dataType: DT_2, data: unknown) => void;
    And: <R1 extends import("./data-types/types").RecordTypeSchema, R2 extends import("./data-types/types").RecordTypeSchema>(recordDataTypeA: import("./data-types/types").RecordOf<R1>, recordDataTypeB: import("./data-types/types").RecordOf<R2>) => import("./intrinsic-type-utils/types").SumRecord<R1, R2>;
    Exclude: <U extends import("./data-types/types").OneOf<any[]>, E extends "string" | "number" | "boolean" | "symbol" | "undefined" | "function" | "unknown" | "integer" | "null" | "stringnumeral" | "stringinteger">(union: U, ...excludeTypes: E[]) => import("./intrinsic-type-utils/types").ExcludeOneOf<U, E>;
    Omit: <R_1 extends import("./data-types/types").RecordTypeSchema, K extends keyof R_1>(recordDataType: import("./data-types/types").RecordOf<R_1>, ...omitKeys: readonly K[]) => import("./intrinsic-type-utils/types").OmitRecord<R_1, K>;
    Partial: <R_2 extends import("./data-types/types").RecordTypeSchema>(recordDataType: import("./data-types/types").RecordOf<R_2>) => import("./intrinsic-type-utils/types").PartialRecord<R_2>;
    Pick: <R_3 extends import("./data-types/types").RecordTypeSchema, K_1 extends keyof R_3>(recordDataType: import("./data-types/types").RecordOf<R_3>, ...pickKeys: readonly K_1[]) => import("./intrinsic-type-utils/types").PickRecord<R_3, K_1>;
    Required: <R_4 extends import("./data-types/types").RecordTypeSchema>(recordDataType: import("./data-types/types").RecordOf<R_4>) => import("./intrinsic-type-utils/types").RequiredRecord<R_4>;
    DataType: {
        RecordOf<TS extends import("./data-types/types").RecordTypeSchema>(args: TS): import("./data-types/types").RecordOf<TS>;
        ArrayOf<DT_3 extends import("./data-types/types").AllDataTypes[]>(...args: DT_3): import("./data-types/types").ArrayOf<DT_3>;
        SetOf<DT_4 extends import("./data-types/types").AllDataTypes[]>(...args: DT_4): import("./data-types/types").SetOf<DT_4>;
        OneOf<DT_5 extends import("./data-types/types").AllDataTypes[]>(...args: DT_5): import("./data-types/types").OneOf<DT_5>;
        Literal<V extends string | number | boolean>(value: V): import("./data-types/types").Literal<V>;
        EnumMember<M extends string | number>(enumMember: M): import("./data-types/types").EnumMember<M>;
        Enum<T extends string, TEnumValue extends string | number>(enumInstance: { [key in T]: TEnumValue; }): import("./data-types/types").Enum<TEnumValue>;
        Unknown: "unknown";
        String: "string";
        Number: "number";
        Int: "integer";
        Boolean: "boolean";
        Symbol: "symbol";
        Function: "function";
        Null: "null";
        Undefined: "undefined";
        StringNumeral: "stringnumeral";
        StringInt: "stringinteger";
    };
};
export default _default;
export { DataType } from "./data-types/data-types";
export { GetDataType } from "./data-types/type-utils";
export { AllDataTypes, ArrayOf, BasicDataType, ComplexDataType, Enum, EnumMember, FieldDescriptor, Literal, OneOf, RecordOf, RecordTypeSchema as TypeSchema, SetOf, } from "./data-types/types";
export * from "./intrinsic-type-utils/index";
export { createTypeGuardedFunction, createValidatedFunction, } from "./validation-algorithms/create-validated-function";
export { createChecker, createValidator } from "./validation-algorithms/create-validator";
export { ensureDataType } from "./validation-algorithms/ensure-data-type";
